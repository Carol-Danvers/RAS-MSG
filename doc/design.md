# 微服务架构下的数据一致性解决方案

在分布式服务架构下，数据往往分散在不同的节点，节点之间数据的一致性是我们非常需要关心的问题。例如在微服务架构中，不同业务往往拆分解耦，每个服务都有独立的数据库做数据存储。而这些服务又相互关联，必须保证分布式事务中数据的一致性。  

常用的解决方案为`二阶段提交协议`。二阶段提交提供了一套完整的分布式事务的解决方案，遵循事务严格的 ACID 特性。但是其本身是一个**阻塞**协议，当一个节点在等待回复消息时进入阻塞状态。其他需要这些资源的处理事务需要等待。如果协调者挂掉，参与者将永远不能结束它们的事务。  

二阶段提交协议从第一阶段准备阶段开始就要将所涉及的业务数据锁定，并且锁定过程跨越整个提交流程。在`高并发`和`涉及业务模块较多`的情况下，对数据库的性能影响较大。导致分布式系统下无法直接使用此方案来解决数据一致性问题，但它提供了解决分布式系统下数据一致性问题的思路。

这里我们考虑结合BASE理论提出一个解决方案。系统在处理业务时，**记录每一步的临时状态**。`当出现异常时，根据状态判断是否继续处理请求或者退回原始状态，从而达到数据的最终一致。`

# 可靠消息最终一致性
这里的解决方案为利用MQ来实现二阶段提交（事务性）。  
方案涉及三个模块：
* 上游应用，执行业务并发送 MQ 消息。
* 可靠消息服务和 MQ 消息组件，协调上下游消息的传递，并确保上下游数据的一致性。
* 下游应用，监听 MQ 的消息并执行自身业务。

### 上游应用执行业务并发送 MQ 消息（第一阶段）
上游应用将本地业务执行和消息发送绑定在同一个本地事务中，**保证要么本地操作成功并发送 MQ 消息，要么两步操作都失败并回滚**。  
1. 上游应用发送待确认消息到可靠消息系统
2. 可靠消息系统保存`待确认`消息并返回
3. 上游应用执行本地业务
4. 上游应用通知可靠消息系统确认业务已执行并发送消息。
5. 可靠消息系统修改消息状态为`发送状态（已发送）`并将消息投递到 MQ 中间件。

可靠消系统一开始为`待确认`状态，当步骤1-3出错时，上游应用整个事务回退，不影响一致性。而当4、5发生错误时，会出现不一致性，需要做如下处理：  
1. 可靠消息服务定时监听消息的状态，如果存在状态为`待确认并且超时`的消息，则表示上游应用和可靠消息交互中的步骤 4 或者 5 出现异常。
2. 向上游应用查询业务执行的情况
3. 业务未执行，则删除该消息，保证业务和可靠消息服务的一致性。业务已执行，则修改消息状态为已发送，并发送消息到 MQ 组件。

### 下游应用监听 MQ 消息并执行业务（第二阶段）
下游应用监听 MQ 消息并执行业务，并且将消息的消费结果通知可靠消息服务。  
可靠消息的状态需要和下游应用的业务执行保持一致，可靠消息状态不是已完成时，确保下游应用未执行，可靠消息状态是已完成时，确保下游应用已执行。  

1. 下游应用监听 MQ 消息组件并获取消息
2. 下游应用根据 MQ 消息体信息处理本地业务
3. 下游应用向 MQ 组件自动发送 ACK 确认消息被消费
4. 下游应用通知可靠消息系统消息被成功消费，可靠消息将该消息状态更改为`已完成`。

步骤4发生错误时，会造成不一致性，此时可靠消息服务中存在消息状态为`已发送并且超时`的消息，执行以下操作：  
1. 可靠消息服务定时查询状态为已发送并超时的消息
2. 可靠消息将消息重新投递到 MQ 组件中
3. **下游应用监听消息，在满足幂等性的条件下，重新执行业务。**
4. 下游应用通知可靠消息服务该消息已经成功消费。